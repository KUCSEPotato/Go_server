## 1. 채널 닫기 (`close(ch)`)

```go
ch := make(chan int, 2)
ch <- 1
ch <- 2
close(ch)
```

* 채널에 `1`, `2`를 넣고 닫습니다.
* `close(ch)`는 **송신을 더 이상 할 수 없게 만드는 것**이지, 이미 들어있는 데이터를 버리진 않습니다.
* 닫힌 채널에서 **수신은 여전히 가능**합니다.
* 단, 닫힌 채널에 다시 **송신을 시도하면 패닉(panic)** 발생합니다.

## 2. 닫힌 채널에서 수신

```go
fmt.Println(<-ch) // 1
fmt.Println(<-ch) // 2
```

* 버퍼에 들어있던 값이 정상적으로 출력됩니다.

## 3. 닫힌 채널에서 더 이상 값이 없을 때

```go
if _, success := <-ch; !success {
    fmt.Println("no more values.")
}
```

* 닫힌 채널에서 값을 꺼내려고 하면:

  * 이미 들어있는 데이터가 있으면 그 데이터를 반환.
  * 데이터가 없으면 **타입의 zero value**(`0`, `""`, `nil`, …)를 반환하고,
    두 번째 리턴값 `success`가 **false**가 됩니다.
* 이걸로 채널이 닫혔음을 감지할 수 있어요.

## 4. `range` 문으로 반복

```go
for i := range ch {
    fmt.Println(i)
}
```

* 채널이 닫히면 `range` 반복문이 자동으로 종료됩니다.
* 즉, `if _, ok := <-ch` 패턴을 반복해서 쓰는 걸 `range`가 더 간단하게 해주는 거예요.

## 5. 출력 흐름 정리

실제로 실행하면:

```
1
2
no more values.
```

* 마지막 `range`는 이미 채널이 닫히고 값이 다 빠져나갔기 때문에 실행되지 않고 바로 종료됩니다.


## 6. 핵심 포인트

* **`close(ch)`는 수신자에게 "더 이상 값이 안 들어와"라는 신호를 주는 것.**
* 닫힌 채널에서 수신하면 → 값 없을 때는 `zero value`, `ok == false`.
* 닫힌 채널에 송신하면 → `panic: send on closed channel`.
* **여러 고루틴이 수신하는 상황**에서, `range`를 통해 “값 다 받을 때까지” 깔끔히 처리 가능.

정리하면, 네 코드에서 보여준 **방법1(`if _, ok := <-ch`)** 과 **방법2(`for i := range ch`)** 는 채널 닫힘을 감지하고 안전하게 수신을 끝내는 대표적인 패턴이에요.

