## 1. 채널 기본 동작 (Unbuffered Channel)

```go
c := make(chan int) // 버퍼 없는 채널
c <- 1              // 수신자가 없으므로 데드락
```

* **버퍼가 없는 채널(unbuffered)** 은 **동기적(synchronous)** 입니다.
  즉, **송신자가 값을 보낼 때 동시에 누군가가 값을 받아야만** 전송이 완료됩니다.
* `c <- 1`을 실행하면, **값을 건네줄 상대(수신자)가 준비될 때까지 블로킹**됩니다.
* 지금 코드에서는 `<-c` 수신이 `c <- 1` 이후에 오기 때문에, **첫 번째 송신이 막혀서** 프로그램이 데드락에 빠집니다.

## 2. 버퍼 있는 채널 (Buffered Channel)

```go
ch := make(chan int, 1) // 버퍼 크기 1
ch <- 1                 // 버퍼가 1칸 있으므로 바로 성공
fmt.Println(<-ch)       // 수신 시 값 출력
```

* **버퍼 있는 채널(buffered)** 은 **비동기적(asynchronous)** 성격을 가집니다.
  버퍼 크기만큼은 **즉시 보낼 수 있고, 수신자가 없어도 블로킹되지 않음**.
* 다만, **버퍼가 가득 차면 송신은 다시 블로킹**됩니다.
  예:

  ```go
  ch := make(chan int, 1)
  ch <- 1 // 버퍼 채움
  ch <- 2 // 버퍼가 꽉 찼으므로 수신자 없으면 데드락
  ```

## 3. 정리: 동기 vs 비동기

* **Unbuffered 채널**: 송신과 수신이 동시에 이루어져야 한다. (→ 동기적, handshake 통신 느낌)
* **Buffered 채널**: 버퍼에 여유가 있으면 송신은 즉시 진행된다. (→ 비동기적)

## 4. 고루틴과 함께 쓰는 올바른 패턴

보통 채널은 고루틴과 함께 사용해야 의미가 있습니다.
예시:

```go
package main

import (
	"fmt"
)

func main() {
	c := make(chan int)

	// 고루틴에서 값 송신
	go func() {
		c <- 42
	}()

	// 메인 고루틴에서 값 수신
	fmt.Println(<-c) // 42 출력
}
```

여기서는 송신과 수신이 **서로 다른 고루틴**에서 발생하므로 데드락이 없습니다.

## 5. 비유

* **Unbuffered 채널** = 물건을 직접 건네줄 때: 상대방이 손을 내밀지 않으면 건네줄 수 없음.
* **Buffered 채널** = 택배 보관함(버퍼): 상대방이 당장 없어도 보관함에 넣어둘 수 있음. 단, 보관함이 꽉 차면 더 못 넣음.

## 6. 송신자와 수신자
- 고루틴에서 **수신자(receiver)** 와 **송신자(sender)** 는 **채널(channel)을 통해 데이터를 주고받는 주체**를 말합니다.

### 1. 채널 기본 문법

* **송신 (send)**: `ch <- value`
  → `value`를 채널 `ch`로 보냄 (sender).

* **수신 (receive)**: `value := <-ch`
  → 채널 `ch`로부터 값을 꺼냄 (receiver).

즉, 채널은 **고루틴 간 통신 도구**이고, 그 순간 데이터를 보내는 쪽이 **송신자**, 받는 쪽이 **수신자**가 됩니다.

### 2. 예제 (단일 고루틴, 데드락 발생)

```go
func main() {
    ch := make(chan int)
    ch <- 10          // 송신자 (main 고루틴)
    fmt.Println(<-ch) // 수신자 (main 고루틴)
}
```

* 이 코드는 데드락 발생 
* 이유: 송신과 수신이 같은 고루틴에서 순차적으로 실행되기 때문에,
  첫 번째 `ch <- 10`에서 "받아줄 사람"을 기다리다가 멈춤.

### 3. 예제 (고루틴 간 송수신)

```go
package main

import (
    "fmt"
)

func main() {
    ch := make(chan int)

    // 송신자 (고루틴)
    go func() {
        ch <- 42
    }()

    // 수신자 (메인 고루틴)
    value := <-ch
    fmt.Println("받은 값:", value)
}
```

* `go func()` 내부의 고루틴이 **송신자** → `ch <- 42`
* `main()`의 `<-ch`가 **수신자**
* 서로 다른 고루틴에서 실행되므로 데드락 없이 동작

### 4. 비유

* **송신자**: 우체부가 편지를 채널(우체통)에 넣는 행위
* **수신자**: 사람이 채널(우체통)에서 편지를 꺼내는 행위
* 채널이 없으면 고루틴끼리 직접 데이터를 교환할 수 없음 → 채널이 "안전한 전달 경로" 역할

### 5. 동기 vs 비동기 상황

* **버퍼 없는 채널**

  * 송신자는 수신자가 준비될 때까지 기다림.
  * 수신자도 송신자가 값을 보낼 때까지 기다림.
  * → 서로 "손 맞잡고 교환"하는 느낌.

* **버퍼 있는 채널**

  * 송신자는 버퍼에 남는 공간이 있으면 즉시 보내고 넘어감.
  * 수신자는 나중에 와서 버퍼에서 꺼낼 수 있음.
  * → "택배 보관함" 같은 느낌.

정리:

* **송신자** = `ch <- value` 실행하는 고루틴
* **수신자** = `<-ch` 실행하는 고루틴
* 채널은 이 둘 사이의 "안전한 데이터 교환 창구"

