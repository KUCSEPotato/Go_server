# Route Handler
## 1. Route Handler
- 특정 HTTP 메서드(GET, POST, PUT …) + 경로(path) 에 매칭되는 요청이 들어왔을 때 실행할 함수를 등록하는 것
```go
// Signature
// HTTP methods
func (app *App) Get(path string, handlers ...Handler) Router
func (app *App) Head(path string, handlers ...Handler) Router
func (app *App) Post(path string, handlers ...Handler) Router
func (app *App) Put(path string, handlers ...Handler) Router
func (app *App) Delete(path string, handlers ...Handler) Router
func (app *App) Connect(path string, handlers ...Handler) Router
func (app *App) Options(path string, handlers ...Handler) Router
func (app *App) Trace(path string, handlers ...Handler) Router
func (app *App) Patch(path string, handlers ...Handler) Router

// Add allows you to specifiy a method as value
func (app *App) Add(method, path string, handlers ...Handler) Router

// All will register the route on all HTTP methods
// Almost the same as app.Use but not bound to prefixes
func (app *App) All(path string, handlers ...Handler) Router

// Example
// Simple GET handler
app.Get("/api/list", func(c *fiber.Ctx) error {
  return c.SendString("I'm a GET request!")
})

// Simple POST handler
app.Post("/api/register", func(c *fiber.Ctx) error {
  return c.SendString("I'm a POST request!")
})
```

## 2. Use(middle ware/Prefix Catcher)
- Use는 특정 경로(접두어)로 시작하는 모든 요청을 가로채는 미들웨어를 등록할 때 사용.
    - Middelware: 요청이 최종 라우트 핸들러에 도착하기 전에 중간에서 실행되는 함수
``` go
// Signature
func (app *App) Use(args ...interface{}) Router
// 인자로 prefix(string, []string) + handler(하나 이상) 전달 가능.

// Example
// 모든 요청에 적용
app.Use(func(c *fiber.Ctx) error {
    fmt.Println("Request received")
    return c.Next() // 다음 핸들러로 진행
})

// /api 로 시작하는 요청에만 적용
app.Use("/api", func(c *fiber.Ctx) error {
    return c.Next()
})

// 여러 prefix 지정 가능
app.Use([]string{"/api", "/home"}, func(c *fiber.Ctx) error {
    return c.Next()
})

// 여러 핸들러를 체인처럼 붙일 수도 있음
app.Use("/api",
  func(c *fiber.Ctx) error {
    c.Set("X-Custom-Header", "12345")
    return c.Next()
  },
  func(c *fiber.Ctx) error {
    fmt.Println("Second middleware for /api")
    return c.Next()
  },
)
```
## 3. Route vs Use
| 특징     | Route Handler (`Get`, `Post` 등) | Use (미들웨어)                        |
| ------ | ------------------------------- | --------------------------------- |
| 매칭 기준  | 정확한 HTTP 메서드 + 경로               | 경로 prefix                         |
| 실행 위치  | 요청을 최종 처리하는 핸들러                 | 주로 전/후 처리 (로그, 인증, 헤더 등)          |
| 체인 가능성 | 여러 개 등록 가능 (순서대로 실행)            | 여러 미들웨어 체인 가능 (Next()로 제어)        |
| 대표 예시  | `app.Get("/user/:id", handler)` | `app.Use("/api", authMiddleware)` |

# Mount and MountPath
## 1. Mount
- 보통은 하나의 Fiber instance (app := fiber.New())로 서버를 돌리지만,
    - Fiber는 여러 개의 앱 인스턴스를 만들어서 "부모-자식" 구조로 합칠 수 있게 해준다.
- app.Mount(prefix, subApp) 호출 -> 특정 경로 아래에 다른 Fiber 앱을 붙임.

```go
// signature
func (a *App) Mount(prefix string, app *App) Router
// app: subApp(*fiber.App) instance

//Example
func main() {
    app := fiber.New()
    micro := fiber.New()

    // micro 앱을 /john 경로에 붙이기
    app.Mount("/john", micro)

    // 이제 micro의 라우트는 /john 밑에서 동작
    micro.Get("/doe", func(c *fiber.Ctx) error {
        return c.SendStatus(fiber.StatusOK)
    })

    app.Listen(":3000")
}
```
- Python framework인 Flask, FastAPI의 블루프린트와 유사
    - 차이점은 아래와 같음.
        - Flask/FastAPI에서는 Blueprint/Router 객체를 등록하는 방식.
        - Fiber에서는 *서브 Fiber 앱(fiber.App) 자체를 mount.
        - 즉, Fiber는 “라우터 단위”가 아니라 “서브 애플리케이션 단위”를 붙이는 느낌이라 조금 더 독립성이 강함.

## 2. MountPath
- 특정 앱이 어디에 mount 되었는지 반환.
``` go
app := fiber.New()
one := fiber.New()
two := fiber.New()
three := fiber.New()

two.Mount("/three", three) // three는 /one/two/three에 달림
one.Mount("/two", two)
app.Mount("/one", one)

fmt.Println(one.MountPath())   // "/one"
fmt.Println(two.MountPath())   // "/one/two"
fmt.Println(three.MountPath()) // "/one/two/three"
fmt.Println(app.MountPath())   // ""
```
- caution!!!!!!!
    - Mount 순서가 매우 중요합니다.
        - mountPath가 제대로 계산되려면 가장 깊은 sub-app부터 mount해야 합니다.
        - 즉, 위 코드에서는 three -> two -> one -> app 순서대로 해야 경로가 올바르게 나옵니다.
    - 주로 대형 프로젝트를 모듈화 할때 많이 사용합니다.